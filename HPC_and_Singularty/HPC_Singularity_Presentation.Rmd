---
title: "HPC and Singularity"
subtitle: "<br> A Guide to Go"
author: "Alexis Lucattini"
date: "Wed 13th March 2019"
output:
  xaringan::moon_reader:
    css: "libs/remark-css-0.0.1/HPC_and_Singularty.css"
    lib_dir: libs
    nature:
      highlightStyle: pygments
      highlightLines: true
      countIncrementalSlides: false
    self-contained: no

---

# Introduction
.pull-left[
## What we will cover:
.baby-bear[
Building from pre-built containers
Installations via a recipe script
Running your containers on a HPC
Developing module files for your containers
]]
.pull-right[
## What we wont cover:
.baby-bear[
Using 'make'
Using 'gcc'
Using 'apt'
Using 'docker'
Using 'sbatch'
]
]

---

# Why Containers?

.center[<img src=https://imgs.xkcd.com/comics/containers.png width=45%>]

---

# Why Containers
## Reproducible Results

.center[<img src=images/dolly_reproducible.jpg width=35%>]

---

# Why Containers
## Environment independent

.center[<img src=images/polar_bear_env.jpg width=50%>]

---

# Why Containers
## Easily installation

.center[<img src=images/britney.jpg width=45%>]

---

# Which containers
## Singularity > Docker
.pull-left[
.baby-bear[
    + HPC friendly (no root required for running)
    + Reduce security issues
    + Smaller overhead
    + Segmented recipes
    + Less community
    + Can import dockerfiles anyways
]
]
.pull-right[
.baby-bear[
+ Steep Learning curve
+ Some system-admin knowledge required 
+ Developing technology
+ Locale Inheritance
]
]

???

(apt-get installation methods)
(some bugs fixed required)
 
---

# Overview of environment wrapping

.pull-left[
.baby-bear[
+ Containers and HPC scheduling initially can be quite overwhelming.<br></br> 
+ This diagram is not intended to intimidate but for debugging assistance.
]
]
.pull-right[
.center[<img src=images/sbatch_singularity_diagram.png width=100%>]
]

---

# Installation Overview

.center[<img src=images/singularity_diagram.png width=80%>]

---

# Building a container

.pull-left[
.baby-bear[
+ Choose a base container to start with.<br></br>
+ Bases can be found at [SingularityHub repo](https://singularity-hub.org/collections)<br></br>
+ Or from the [DockerHub repo](https://hub.docker.com/).<br></br>
]
]
.pull-right[
.baby-bear[
+ Use the `%runscript` to specfiy which command to run inside the container.<br></br>
+ Usually prefix with 'exec' and end with `${@}` which represents any trailing parameters<br></br>
]
]


---

.pull-left[
### DockerHub example
```{bash, eval=FALSE}
$ cat recipe.docker
BootStrap: docker
From: r-base:3.5.1

%runscript
exec R ${@}
```
]
.pull-right[
### SingularityHub example
```{bash, eval=FALSE}
$ cat recipe.singularity
BootStrap: shub
From: MPIB/singularity-r:3.5.1

%runscript
exec R ${@}
```
]

---

# Building the container

### Dockerhub Example
```{bash, eval=FALSE}
$ sudo singularity build \
  r_from_docker_3.5.2.simg recipe
```


### Singularity Example
```{bash, eval=FALSE}
$ sudo singularity build \
  r_from_shub_3.5.2.simg recipe
```

---

# Running the container

With just those two lines we now have containers that can the R console!
```{bash eval=FALSE}
$ singularity run r_from_shub_3.5.2.simg
```

---

# Shell inside the container

.pull-left[
.baby-bear[
*Why shell*  
Curious to see what's under the hood?
We can shell into the container using the command below,
use `exit` to exit the container.
]
]
.pull-right[
.baby-bear[
*Traversing activity*  
When inside the container try the following commands.  
`ls /data`  
`ls /home`  
Which one of these worked? What does this mean?
]
]

```{bash, eval=FALSE}
$ singularity shell r_from_shub_3.5.2.simg
```

---

# Specify an installation script

```{bash, eval=FALSE}
$ cat recipe.singularity
BootStrap: shub
From: MPIB/singularity-r:3.5.1

%help
To get started with this image, try
singularity run r_from_shub_3.5.1.simg


%post
# Preinstallall the tidyverse and BiocManager for the users
Rscript --vanilla -e 'install.packages("tidyverse")'
Rscript --vanilla -e 'install.packages("BiocManager")'

%runscript
exec R ${@}
```

???

The R container is pretty good, but maybe we could give our users a bit of a head-start. Using the %post section we’ll preinstall a few packages to get them going.

---

# The pain of R
.baby-bear[
Oh dear, it appears we don’t have a CRAN mirror.  
We can add one in using %files section and ensure it’s there for all users.
]


.tiny[
```{bash, eval=FALSE, size='tiny'}
$ cat recipe.singularity
BootStrap: shub
From: MPIB/singularity-r:3.5.1

%help
To get started with this image, try
singularity run r_from_shub_3.5.1.simg

%files
r_profile.site /usr/local/lib/R/etc/Rprofile.site

%post
Rscript --vanilla -e 'install.packages("tidyverse")'
Rscript --vanilla -e 'install.packages("BiocManager")'

%runscript
exec R ${@}
```
]

???

TODO: link to the rprofile file.

---

# Apps

Our container now runs R interactively.  
This may not suit the needs of everyone.

* Apps allow users to specify what commands they wish to run.
* Apps can also have their own specific:
  + %files
  + %environment
  + %post

Just specify with the %app prefix and complete with the app name.

???

But say our user just needs the R platform, not the interactive suite? We could create a new container with a new %runscript parameter that use Rscript instead of R. Seems like a waste of a container. So this segues nicely into Apps.

---

# App example

```{bash, eval=FALSE}
$ cat recipe.singularity
BootStrap: shub
From: MPIB/singularity-r:3.5.1

%help
To get started with this image, try
singularity run r_from_shub_3.5.1.simg

%apphelp Rscript
Use container in non-interactive mode
singularity run r_from_shub.3.5.2.simg --no-init-file my_r_script

%apprun Rscript
exec Rscript ${@}

%files
r_profile.site /usr/local/lib/R/etc/Rprofile.site

%post
Rscript --vanilla -e 'install.packages("tidyverse")'
Rscript --vanilla -e 'install.packages("BiocManager")'

%runscript
exec R ${@}

$ sudo singularity build r_from_shub_3.5.1.simg recipe
```

---

# App example

