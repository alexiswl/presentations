---
title: "HPC and Singularity"
subtitle: "<br> A Guide to Go"
author: "Alexis Lucattini"
date: "Wed 13th March 2019"
output:
  xaringan::moon_reader:
    css: "libs/remark-css-0.0.1/HPC_and_Singularty.css"
    lib_dir: libs
    nature:
      highlightStyle: pygments
      highlightLines: true
      countIncrementalSlides: false
    self-contained: no

---

# Introduction
.pull-left[
## Covered:
.baby-bear[
* Building from pre-built containers  
* Installations via a recipe
* Running containers on your HPC  
* Developing module files for containers  
]]
.pull-right[
## Not covered:
.baby-bear[
* Using 'make'  
* Using 'gcc'  
* Using 'apt'  
* Using 'docker'  
* Using 'sbatch'  
]
]

---

# Why Containers?

.center[<img src=https://imgs.xkcd.com/comics/containers.png width=45%>]

---

# Why Containers
## Reproducible Results

.center[<img src=images/dolly_reproducible.jpg width=35%>]

---

# Why Containers
## Environment independent

.center[<img src=images/polar_bear_env.jpg width=50%>]

---

# Why Containers
## Easily installation

.center[<img src=images/britney.jpg width=45%>]

---

# Which containers
## Singularity > Docker
.pull-left[
.baby-bear[
    + HPC friendly (no root required for running)
    + Reduce security issues
    + Smaller overhead
    + Segmented recipes
    + Less community
    + Can import dockerfiles anyways
]
]
.pull-right[
.baby-bear[
+ Steep Learning curve
+ Some system-admin knowledge required 
+ Developing technology
+ Locale Inheritance
]
]

???

(apt-get installation methods)
(some bugs fixed required)
 
---

# Environment wrapping

.pull-left[
.baby-bear[
+ Containers and HPC scheduling initially can be quite overwhelming.<br></br> 
+ This diagram is not intended to intimidate but for debugging assistance.
]
]
.pull-right[
.center[<img src=images/sbatch_singularity_diagram.png width=100%>]
]

---

# Installation Overview

.center[<img src=images/singularity_diagram.png width=80%>]

---

# Building a container

.pull-left[
.baby-bear[
+ Choose a base container to start with.<br></br>
+ Bases can be found at [SingularityHub repo](https://singularity-hub.org/collections)<br></br>
+ Or from the [DockerHub repo](https://hub.docker.com/).<br></br>
]
]
.pull-right[
.baby-bear[
+ Use the `%runscript` to specfiy which command to run inside the container.<br></br>
+ Usually prefix with 'exec' and end with `${@}` which represents any trailing parameters<br></br>
]
]


---

# Examples

.pull-left[
## DockerHub
```{bash, eval=FALSE}
$ cat recipe.docker
BootStrap: docker
From: r-base:3.5.1

%runscript
exec R ${@}
```
]
.pull-right[
## SingularityHub
```{bash, eval=FALSE}
$ cat recipe.singularity
BootStrap: shub
From: MPIB/singularity-r:3.5.1

%runscript
exec R ${@}
```
]

---

# Building the container

### Dockerhub Example
```{bash, eval=FALSE}
$ sudo singularity build \
  r_from_docker_3.5.2.simg recipe
```


### Singularity Example
```{bash, eval=FALSE}
$ sudo singularity build \
  r_from_shub_3.5.2.simg recipe
```

---

# Running the container

With just those two lines we now have containers that can the R console!
```{bash eval=FALSE}
$ singularity run r_from_shub_3.5.2.simg
```

---

# Shell inside the container

.pull-left[
.baby-bear[
*Why shell*  
Curious to see what's under the hood?
We can shell into the container using the command below,
use `exit` to exit the container.
]
]
.pull-right[
.baby-bear[
*Traversing activity*  
When inside the container try the following commands.  
`ls /data`  
`ls /home`  
Which one of these worked? What does this mean?
]
]

```{bash, eval=FALSE}
$ singularity shell r_from_shub_3.5.2.simg
```

---

# Write a recipe
.small-code[
```{bash, eval=FALSE}
$ cat recipe.singularity
BootStrap: shub
From: MPIB/singularity-r:3.5.1

%help
To get started with this image, try
singularity run r_from_shub_3.5.1.simg


%post
# Preinstallall the tidyverse and BiocManager for the users
Rscript --vanilla -e 'install.packages("tidyverse")'
Rscript --vanilla -e 'install.packages("BiocManager")'

%runscript
exec R ${@}
```
]

.footnote[
If this script fails for you, please see the next slide before panicking
]

???

The R container is pretty good, but maybe we could give our users a bit of a head-start.   
Using the %post section weâ€™ll preinstall a few packages to get them going.
If this script fails for you, you've done good.

---

# Adding files
.baby-bear[
No CRAN mirror specified?  
No worries, we can add [one](rprofile.site) in using the %files section.
]

.small-code[
```{bash, eval=FALSE}
$ cat recipe.singularity
BootStrap: shub
From: MPIB/singularity-r:3.5.1

%help
...

%files
r_profile.site /usr/local/lib/R/etc/Rprofile.site

%post
Rscript --vanilla -e 'install.packages("tidyverse")'
...

%runscript
exec R ${@}
```
]

???

TODO: link to the rprofile file.

---

# Apps

.baby-bear[
Our container now runs R interactively,  
however, this may not suit the needs of everyone.

* Apps allow users to specify what commands they wish to run.
* Apps can also have their own specific:
  + %files
  + %environment
  + %post

Just specify with the %app prefix and complete with the app name.
]

???

But say our user just needs the R platform, not the interactive suite? We could create a new container with a new %runscript parameter that use Rscript instead of R. Seems like a waste of a container. So this segues nicely into Apps.

---

# App example

.small-code[
```{bash, eval=FALSE}
$ cat recipe.singularity
BootStrap: shub
From: MPIB/singularity-r:3.5.1

%help
...

%apphelp Rscript
Use container in non-interactive mode
singularity run r_from_shub.3.5.2.simg --no-init-file my_r_script

%apprun Rscript
exec Rscript ${@}

...
%files
%post
%runscript
...

```
]

---

# TODO

commentary,
environment,
biocontainers
